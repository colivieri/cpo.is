'use strict';

exports.__esModule = true;

var _objectWithoutProperties2 = require('babel-runtime/helpers/objectWithoutProperties');

var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _animationUtils = require('./animation-utils');

var _animationUtils2 = _interopRequireDefault(_animationUtils);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _objectAssign = require('object-assign');

var _objectAssign2 = _interopRequireDefault(_objectAssign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CSSAnimate = function (_PureComponent) {
  (0, _inherits3.default)(CSSAnimate, _PureComponent);

  function CSSAnimate(props, context) {
    (0, _classCallCheck3.default)(this, CSSAnimate);

    var _this = (0, _possibleConstructorReturn3.default)(this, _PureComponent.call(this, props, context));

    _this.animateEnter = _this.animateEnter.bind(_this);
    _this.animateLeave = _this.animateLeave.bind(_this);

    _this.onAnimationStart = _this.onAnimationStart.bind(_this);
    _this.onAnimationEnd = _this.onAnimationEnd.bind(_this);
    _this.onTransitionEnd = _this.onTransitionEnd.bind(_this);

    _this.firstUpdate = true;
    _this.hasAnimationListener = false;

    _this.state = {
      animateEnterEnd: false,
      animateLeaveEnd: false,
      animateEnter: props.animateEnter,
      animateLeave: props.animateLeave,
      animateEnterStart: false,
      animateLeaveStart: false,
      width: null,
      height: null
    };
    return _this;
  }

  CSSAnimate.prototype.animateEnter = function animateEnter() {
    var element = _reactDom2.default.findDOMNode(this.element);
    var height = element ? element.scrollHeight : 0;

    this.setState({
      animateEnterEnd: false,
      animateEnter: true,
      height: height,
      animateLeave: false
    });
  };

  CSSAnimate.prototype.animateLeave = function animateLeave() {
    var element = _reactDom2.default.findDOMNode(this.element);
    var width = element ? element.clientWidth : 0;
    this.setState({
      animateLeaveEnd: false,
      animateLeave: true,
      animateEnter: false,
      width: width,
      height: 0
    });
  };

  // shouldComponentUpdate(nextProps, nextState) {
  //   return (nextProps.animateLeave  !== this.props.animateLeave || nextProps.animateEnter !== this.props.animateEnter)
  // }

  CSSAnimate.prototype.componentWillUpdate = function componentWillUpdate(nextProps, nextState) {

    // console.log(this.props.name, 'componentWillUpdate',nextProps, nextState);

    var element = _reactDom2.default.findDOMNode(this.element);
    if (nextProps.animateLeave && !this.props.animateLeave && !this.state.animateLeave) {
      nextState.animateEnterEnd = false;
      nextState.animateLeaveEnd = false;
      nextState.animateEnter = false;
      nextState.animateLeave = true;
      nextState.animateEnterStart = false;
      nextState.animateLeaveStart = false;

      nextState.height = 0;

      this.addAnimationListener();

      if (element && nextProps.leaveAbsolute) {
        nextState.width = element.clientWidth;
      }
    } else if (nextProps.animateEnter && !this.props.animateEnter && !this.state.animateEnter) {
      nextState.animateEnterEnd = false;
      nextState.animateLeaveEnd = false;
      nextState.animateEnter = true;
      nextState.animateLeave = false;
      nextState.animateEnterStart = false;
      nextState.animateLeaveStart = false;

      this.addAnimationListener();

      if (element) {
        nextState.height = element.scrollHeight;
      }
    }
  };

  CSSAnimate.prototype.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
    // static ANIATION_TYPE_ANIMATION = 'animation';
    // static ANIATION_TYPE_TRANSITION = 'transition';
    // static ANIATION_TYPE_NONE = 'none';

    // console.log(this.state, prevState, this.props.animationType, this.firstUpdate, this.props.animationType, this.props.animateEnterName);


    // console.log(this.props.name, 'componentDidUpdate', this.key, this.state, prevState);
    if (this.props.animationType === CSSAnimate.ANIATION_TYPE_TRANSITION) {

      if (!prevState.animateEnterStart && this.state.animateEnterStart) {
        // this.setState({
        //   // animateEnterStart : false,
        // })

        // return;
      } else if (!prevState.animateLeaveStart && this.state.animateLeaveStart) {
        // this.setState({
        //   // animateLeaveStart : false,
        // })
        // return;
      }

      var ms = 0;
      var evt = null;
      var _element = null;

      if (this.firstUpdate && this.state.animateEnter || !prevState.animateEnter && this.state.animateEnter) {
        var _evt;

        _element = _reactDom2.default.findDOMNode(this.element);
        evt = (_evt = {
          preventDefault: function preventDefault() {},
          target: _element,
          type: 'transitionstart',
          animationName: this.props.animateEnterName
        }, _evt['target'] = _element, _evt);
        ms = this.getAnimationDuration(true);
      } else if (this.firstUpdate && this.state.animateLeave || !prevState.animateLeave && this.state.animateLeave) {
        var _evt2;

        _element = _reactDom2.default.findDOMNode(this.element);
        evt = (_evt2 = {
          preventDefault: function preventDefault() {},
          target: _element,
          type: 'transitionstart',
          animationName: this.props.animateLeaveName
        }, _evt2['target'] = _element, _evt2);
        ms = this.getAnimationDuration(false);
      }

      if (evt) {
        this.onAnimationStart(evt);

        // if (this.firstUpdate && ms) {
        //   console.log('WILL FAKE');
        //   this.endTimeout = setTimeout(() => {
        //     this.onAnimationEnd(evt);
        //   }, ms);
        // }
      }

      this.firstUpdate = false;

      // if(!prevState.animateEnter && this.state.animateEnter){
      //   if(this.props.onAnimateEnterStart) {
      //     let timeout = 0;
      //     if(this.props.animateEnterDelay) {
      //       //TODO filter ms s usw
      //       timeout = parseInt(this.props.animateEnterDelay, 10);
      //     }
      //     setTimeout(()=>{
      //       this.props.onAnimateEnterStart(this.createEventObject({
      //         type: 'transitionstart',
      //         preventDefault: ()=>{},
      //       }));
      //     }, timeout);
      //   }
      // }else if(!prevState.animateLeave && this.state.animateLeave){
      //   if(this.props.onAnimateLeaveStart) {
      //     let timeout = 0;
      //     if(this.props.animateEnterDelay) {
      //       //TODO filter ms s usw
      //       timeout = parseInt(this.props.animateEnterDelay, 10);
      //     }
      //     setTimeout(()=>{
      //       this.props.onAnimateEnterStart(this.createEventObject({
      //         type: 'transitionstart',
      //         preventDefault: ()=>{},
      //       }));
      //     }, timeout);
      //   }
      // }
    }

    // nextState.animateLeave = true;
  };

  CSSAnimate.prototype.getAnimationDuration = function getAnimationDuration(animateEnter) {

    if (this.props.animationType === 'none') {
      return 0;
    }

    var element = _reactDom2.default.findDOMNode(this.element);
    // animateEnterDelay
    // animateLeaveDelay
    // animateEnterDuration
    // animateLeaveDuration

    var duration = (animateEnter ? this.props.animateEnterDuration : this.props.animateLeaveDuration) || window.getComputedStyle(element)[_animationUtils2.default.prefix(this.props.animationType) + '-duration'] || 0;
    var delay = (animateEnter ? this.props.animateEnterDelay : this.props.animateLeaveDelay) || window.getComputedStyle(element)[_animationUtils2.default.prefix(this.props.animationType) + '-delay'] || 0;

    if (duration) {
      var factor = duration.indexOf('ms') > -1 ? 1 : 1000;
      duration = parseInt(duration, 10) * factor;
    }

    if (delay) {
      var _factor = delay.indexOf('ms') > -1 ? 1 : 1000;
      delay = parseInt(delay, 10) * _factor;
    }

    var ms = duration + delay + 10;
    return ms;
  };

  CSSAnimate.prototype.addAnimationListener = function addAnimationListener() {

    if (!this.hasAnimationListener) {
      var _element2 = _reactDom2.default.findDOMNode(this.element);
      if (_element2) {
        if (this.props.animationType === CSSAnimate.ANIATION_TYPE_ANIMATION) {
          _animationUtils2.default.onAnimationStart(_element2, this.onAnimationStart);
          _animationUtils2.default.onAnimationEnd(_element2, this.onAnimationEnd);
        } else if (this.props.animationType === CSSAnimate.ANIATION_TYPE_TRANSITION) {
          _animationUtils2.default.onTransitionEnd(_element2, this.onTransitionEnd);
        }
        this.hasAnimationListener = true;
      }
    }
  };

  CSSAnimate.prototype.removeAnimationListener = function removeAnimationListener() {
    if (this.hasAnimationListener) {
      var _element3 = _reactDom2.default.findDOMNode(this.element);
      if (_element3) {
        _animationUtils2.default.offTransitionEnd(_element3, this.onTransitionEnd);
        _animationUtils2.default.offAnimationEnd(_element3, this.onAnimationEnd);
        _animationUtils2.default.offAnimationStart(_element3, this.onAnimationStart);
        this.hasAnimationListener = false;
      }
    }
  };

  CSSAnimate.prototype.componentWillMount = function componentWillMount() {
    _animationUtils2.default.init();
    this.addAnimationListener();
  };

  CSSAnimate.prototype.componentDidMount = function componentDidMount() {

    // console.log(this.props.name, 'componentDidMount');
    _animationUtils2.default.init();
    this.addAnimationListener();

    if (this.state.animateEnter && !this.state.animateEnterStart) {
      this.setState({
        animateEnterStart: true
      });
    } else if (this.state.animateLeave && !this.state.animateLeaveStart) {
      this.setState({
        animateLeaveStart: true
      });
    }
  };

  CSSAnimate.prototype.componentWillUnmount = function componentWillUnmount() {
    this.removeAnimationListener();
    this.element = null;
  };

  CSSAnimate.prototype.render = function render() {
    var _this2 = this;

    var animating = this.state.animateEnter || this.state.animateLeave;
    // console.log(this.props.remove, this.state.animateLeaveEnd, this.props, this.state);

    if (this.props.remove && this.state.animateLeaveEnd) {
      return null;
    }

    // console.log(this.props.name, 'RENDER', this.state);

    var _props = this.props,
        className = _props.className,
        props = (0, _objectWithoutProperties3.default)(_props, ['className']);

    var animationName = null;
    var animationEndName = null;
    var style = this.props.style ? (0, _objectAssign2.default)({}, this.props.style) : {};

    if (this.props.animateEnterName === 'slideDown' /*&& animating || this.state.animateLeaveEnd*/) {
        style.maxHeight = this.state.height;
      }

    if (animating) {
      var _classNames;

      animationName = (0, _classnames2.default)(this.props.animateBaseName, (_classNames = {}, _classNames[this.props.animateEnterStartName] = this.state.animateEnterStart, _classNames[this.props.animateEnterName] = this.state.animateEnter, _classNames['animateEnter'] = this.state.animateEnter, _classNames[this.props.animateLeaveStartName] = this.state.animateLeaveStart, _classNames[this.props.animateLeaveName] = this.state.animateLeave, _classNames['animateLeave'] = this.state.animateLeave, _classNames));

      if (this.state.animateEnter) {
        if (this.props.animateEnterName && this.props.animationType === CSSAnimate.ANIATION_TYPE_ANIMATION) {
          style[this.props.animationType + 'Name'] = this.props.animateEnterDelay;
        }
        if (this.props.transitionEnterProperty && this.props.animationType === CSSAnimate.ANIATION_TYPE_TRANSITION) {
          style[this.props.animationType + 'Property'] = this.props.transitionEnterProperty;
        }

        if (this.props.animateEnterDelay) {
          style[this.props.animationType + 'Delay'] = this.props.animateEnterDelay;
          if ((this.props.hide || this.props.hideEnter) && !this.state.animateEnterStart) {
            style = (0, _objectAssign2.default)({}, style, this.props.hiddenStyle);
            // style.visibility = 'hidden';
          }
        }
        if (this.props.animateEnterDuration) {
          style[this.props.animationType + 'Duration'] = this.props.animateEnterDuration;
        }
        if (this.props.animateEnterTiming) {
          style[this.props.animationType + 'TimingFunction'] = this.props.animateEnterTiming;
        }
      } else if (this.state.animateLeave) {
        if (this.props.leaveAbsolute) {
          style.position = 'absolute';
          style.width = this.state.width + 'px';
        }
        if (this.props.animateLeaveName && this.props.animationType === CSSAnimate.ANIATION_TYPE_ANIMATION) {
          style[this.props.animationType + 'Name'] = this.props.animateLeaveDelay;
        }
        if (this.props.transitionLeaveProperty && this.props.animationType === CSSAnimate.ANIATION_TYPE_TRANSITION) {
          style[this.props.animationType + 'Property'] = this.props.transitionLeaveProperty;
        }
        if (this.props.animateLeaveDelay) {
          style[this.props.animationType + 'Delay'] = this.props.animateLeaveDelay;
        }
        if (this.props.animateLeaveDuration) {
          style[this.props.animationType + 'Duration'] = this.props.animateLeaveDuration;
        }
        if (this.props.animateLeaveTiming) {
          style[this.props.animationType + 'TimingFunction'] = this.props.animateLeaveTiming;
        }
      }
      style = _animationUtils2.default.prefix(style);
    } else {
      if ((this.state.animateEnterEnd || this.state.animateLeaveEnd) && (this.props.animateEnterEndName || this.props.animateLeaveEndName)) {
        var _classNames2;

        animationEndName = (0, _classnames2.default)((_classNames2 = {}, _classNames2[this.props.animateEnterEndName] = !!this.props.animateEnterEndName && this.state.animateEnterEnd, _classNames2[this.props.animateLeaveEndName] = !!this.props.animateLeaveEndName && this.state.animateLeaveEnd, _classNames2));
      }
    }

    if ((this.props.hide || this.props.hideLeaveEnd) && this.state.animateLeaveEnd) {
      style = (0, _objectAssign2.default)({}, style, this.props.hiddenStyle);
    }

    className = (0, _classnames2.default)('css-animation', className, animationName, animationEndName);

    var element = _react2.default.Children.only(this.props.children);

    // console.log(className);
    // console.log(style);

    if (!element || this.props.tagName) {
      var type = this.props.tagName || 'div';
      element = _react2.default.createElement(type, {
        ref: function ref(element) {
          _this2.element = element;
        },
        className: className,
        style: style
      }, this.props.children);
    } else {
      element = _react2.default.cloneElement(element, {
        ref: function ref(element) {
          _this2.element = element;
        },
        className: (0, _classnames2.default)(element.props ? element.props.className : null, className),
        style: style
      });
    }

    return element;
  };

  CSSAnimate.prototype.createEventObject = function createEventObject(event) {
    if (!event) {
      return null;
    }
    var preventDefault = function preventDefault() {
      event.preventDefault();
    };

    return {
      originalEvent: event,
      preventDefault: preventDefault,
      target: this,
      type: event.type,
      props: this.props
    };
  };

  CSSAnimate.prototype.onTransitionEnd = function onTransitionEnd(e) {
    var element = _reactDom2.default.findDOMNode(this.element);
    if (e.target === element) {
      this.onAnimationEnd({
        preventDefault: function preventDefault() {},
        target: element,
        type: e.type,
        animationName: this.state.animateEnter ? this.props.animateEnterName : this.props.animateLeaveName
      });
    }

    // console.log('ONTRANSITION END', e);
    // this.onAnimationEnd(assign({}, e, {
    //   animationName: this.state.animateEnter ? this.props.animateEnterName : this.props.animateLeaveName,
    // }));
  };

  CSSAnimate.prototype.onAnimationEnd = function onAnimationEnd(e) {
    // console.log(this.element.__proto__)

    if (e.animationName !== this.props.animateEnterName && e.animationName !== this.props.animateLeaveName) {
      return;
    }

    // console.log(this.props.name, 'onAnimationEnd END', e);
    this.removeAnimationListener();

    var element = _reactDom2.default.findDOMNode(this.element);
    var cb;

    if (e.target === element) {

      var state = {};

      if (e.animationName === this.props.animateEnterName) {
        cb = this.props.onAnimateEnterEnd;

        state.animateEnterEnd = true;
        state.animateLeaveEnd = false;
        state.animateEnter = false;
        state.animateLeave = false;
        state.animateLeaveStart = false;
        state.animateEnterStart = false;
      } else if (e.animationName === this.props.animateLeaveName) {
        cb = this.props.onAnimateLeaveEnd;
        state.animateEnterEnd = false;
        state.animateLeaveEnd = true;
        state.animateEnter = false;
        state.animateLeave = false;
        state.animateLeaveStart = false;
        state.animateEnterStart = false;
      }

      // console.log('sdaadsadsadasd', state);

      this.setState(state);

      var evtObj = this.createEventObject(e);
      if (this.props.onAnimationEnd) {
        this.props.onAnimationEnd(evtObj);
      }
      if (cb) {
        cb(evtObj);
      }
    }
  };

  CSSAnimate.prototype.hans = function hans() {
    var _this3 = this;

    if (this.props.timeoutFallback) {
      clearTimeout(this.endTimeout);

      var duration = window.getComputedStyle(element)['animation-duration'] || 0;
      var delay = window.getComputedStyle(element)['animation-delay'] || 0;

      if (duration) {
        var factor = duration.indexOf('ms') > -1 ? 1 : 1000;
        duration = parseInt(duration, 10) * factor;
      }

      if (delay) {
        var _factor2 = delay.indexOf('ms') > -1 ? 1 : 1000;
        delay = parseInt(delay, 10) * _factor2;
      }

      var ms = duration + delay;
      if (ms) {
        this.endTimeout = setTimeout(function () {
          _this3.onAnimationEnd(e);
        }, ms + 10);
      }
    }
  };

  CSSAnimate.prototype.onAnimationStart = function onAnimationStart(e) {
    if (e.animationName !== this.props.animateEnterName && e.animationName !== this.props.animateLeaveName) {
      return;
    }
    // console.log('onamimation start', e);
    var element = _reactDom2.default.findDOMNode(this.element);
    var cb;
    if (e.target === element) {

      if (e.animationName === this.props.animateEnterName) {
        this.setState({
          animateEnterEnd: false,
          animateLeaveEnd: false,
          animateEnter: true,
          animateLeave: false,
          animateLeaveStart: false,
          animateEnterStart: true
        });
        cb = this.props.onAnimateEnterStart;
      } else if (e.animationName === this.props.animateLeaveName) {
        this.setState({
          animateEnterEnd: false,
          animateLeaveEnd: false,
          animateEnter: false,
          animateLeave: true,
          animateLeaveStart: true,
          animateEnterStart: false
        });
        cb = this.props.onAnimateLeaveStart;
      }

      var evtObj = this.createEventObject(e);
      if (this.props.onAnimationStart) {
        this.props.onAnimationStart(evtObj);
      }
      if (cb) {
        cb(evtObj);
      }
    }
  };

  return CSSAnimate;
}(_react.PureComponent);

CSSAnimate.ANIATION_TYPE_ANIMATION = 'animation';
CSSAnimate.ANIATION_TYPE_TRANSITION = 'transition';
CSSAnimate.ANIATION_TYPE_NONE = 'none';
CSSAnimate.propTypes = {
  tagName: _react2.default.PropTypes.string,

  name: _react2.default.PropTypes.string,

  animationType: _react2.default.PropTypes.string,

  animateEnter: _react2.default.PropTypes.bool,
  animateLeave: _react2.default.PropTypes.bool,
  leaveAbsolute: _react2.default.PropTypes.bool,
  enterAbsolute: _react2.default.PropTypes.bool,

  disabled: _react2.default.PropTypes.bool,
  remove: _react2.default.PropTypes.bool,
  hideLeaveEnd: _react2.default.PropTypes.bool,
  hideEnter: _react2.default.PropTypes.bool,
  hide: _react2.default.PropTypes.bool,

  timeoutFallback: _react2.default.PropTypes.bool,

  animateBaseName: _react2.default.PropTypes.string,

  hiddenStyle: _react2.default.PropTypes.object,

  animateEnterName: _react2.default.PropTypes.string,
  animateLeaveName: _react2.default.PropTypes.string,
  animateEnterEndName: _react2.default.PropTypes.string,
  animateLeaveEndName: _react2.default.PropTypes.string,
  animateEnterStartName: _react2.default.PropTypes.string,
  animateLeaveStartName: _react2.default.PropTypes.string,
  transitionEnterProperty: _react2.default.PropTypes.string,
  transitionLeaveProperty: _react2.default.PropTypes.string,

  animateEnterDelay: _react2.default.PropTypes.string,
  animateLeaveDelay: _react2.default.PropTypes.string,

  animateEnterDuration: _react2.default.PropTypes.string,
  animateLeaveDuration: _react2.default.PropTypes.string,

  animateEnterTiming: _react2.default.PropTypes.string,
  animateLeaveTiming: _react2.default.PropTypes.string,

  onAnimationEnd: _react2.default.PropTypes.func,

  onAnimateEnterStart: _react2.default.PropTypes.func,
  onAnimateEnterIteration: _react2.default.PropTypes.func,
  onAnimateEnterEnd: _react2.default.PropTypes.func,

  onAnimateLeaveStart: _react2.default.PropTypes.func,
  onAnimateLeaveIteration: _react2.default.PropTypes.func,
  onAnimateLeaveEnd: _react2.default.PropTypes.func
};
CSSAnimate.defaultProps = {
  animationType: CSSAnimate.ANIATION_TYPE_ANIMATION,
  animateBaseName: 'animated',
  animateEnterName: 'fadeIn',
  animateLeaveName: 'fadeOut',
  name: 'CSSAnimate',
  animateEnterEndName: null,
  animateLeaveEndName: null,
  animateEnterStartName: 'animateEnterStart',
  animateLeaveStartName: 'animateLeaveStart',
  hiddenStyle: {
    'visibility': 'hidden'
  },
  animateEnter: false,
  animateLeave: false,
  hide: false,
  hideEnter: false,
  hideLeaveEnd: false,
  leaveAbsolute: false,
  enterAbsolute: false,
  disabled: false,
  remove: false,
  timeoutFallback: false
};
exports.default = CSSAnimate;
module.exports = exports['default'];